jenkins:
  replicaCount: 1
  image:
    repository: art-hq.intranet.qualys.com:5001/datalake/jenkins
    tag: 0.1.0
    pullPolicy: IfNotPresent
  ingress:
    enabled: false
  service:
    type: NodePort
    nodePortUI: 30010
    ui: 8080
  resources:
    requests:
      cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}

zeppelin:
  replicaCount: 1
  image:
    repository: art-hq.intranet.qualys.com:5001/k8s.gcr.io/zeppelin
    tag: 0.1.26
    pullPolicy: IfNotPresent
  service:
    type: NodePort
    port: 8080
    nodePortUI: 30009
  ingress:
    enabled: false
  resources:
    requests:
      cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}

alluxio:
  replicaCount: 1
  image:
    repository: art-hq.intranet.qualys.com:5001/datalake/alluxio
    tag: 0.1.2
    pullPolicy: IfNotPresent
  service:
    type: ClusterIP
    port: 80
    nodePortRPC: 30001
    nodePortUI: 30002
  ingress:
    enabled: false
  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}

hiveservice:
  replicaCount: 1
  image:
    repository: art-hq.intranet.qualys.com:5001/datalake/hiveservice
    tag: 0.1.12
    pullPolicy: IfNotPresent
  ingress:
    enabled: false
  service:
    type: ClusterIP
    portThrift: 9083
  resources:
    requests:
      cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}

spark:
  spark_master:
    replicaCount: 1
  spark_worker:
    replicaCount: 3
  image:
    spark:
      repository: art-hq.intranet.qualys.com:5001/datalake/spark
      tag: 0.2.13
      pullPolicy: IfNotPresent
    proxy:
      repository: art-hq.intranet.qualys.com:5001/datalake/spark-ui-proxy
      tag: "1.0"
      pullPolicy: IfNotPresent
  ingress:
    enabled: false
  service:
    spark:
      type: None
      portUI: 8080
      portRPC: 7077
    proxy:
      type: NodePort
      port: 80
      nodePortUI: 30006
  resources:
    requests:
      cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}

spark-hadoop:
  spark_master:
    replicaCount: 1
  spark_worker:
    replicaCount: 3
  image:
    spark:
      repository: art-hq.intranet.qualys.com:5001/datalake/spark-hadoop
      tag: 0.2.0
      pullPolicy: IfNotPresent
    proxy:
      repository: art-hq.intranet.qualys.com:5001/datalake/spark-ui-proxy
      tag: "1.0"
      pullPolicy: IfNotPresent
  ingress:
    enabled: false
  service:
    spark:
      type: None
      portUI: 8080
      portRPC: 7077
    proxy:
      type: NodePort
      port: 80
      nodePortUI: 30007
  resources:
    requests:
      cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}

hiveserver:
  replicaCount: 1
  image:
    repository: art-hq.intranet.qualys.com:5001/datalake/hiveserver
    tag: 0.2.3
    pullPolicy: IfNotPresent
  service:
    type: None
    portHTTP: 10001
    portUI: 10002
    nodePortUI: 30004
    nodePortHTTP: 30005
  ingress:
    enabled: false
  resources:
    requests:
      cpu: 100m
  nodeSelector: {}
  tolerations: []
  affinity: {}

postgresql:
  image: "art-hq.intranet.qualys.com:5001/datalake/postgres"
  imageTag: "9.6.9"
  postgresUser: hive
  pullPolicy: IfNotPresent
  ## Default: random 10 character string
  postgresPassword: hive
  ## Inject postgresPassword via a volume mount instead of environment variable
  usePasswordFile: false
  ## Use Existing secret instead of creating one
  ## It must have a postgres-password key containing the desired password
  # existingSecret: 'secret'

  ## Default: the postgres user
  postgresDatabase: metastore
  persistence:
    enabled: true

    ## A manually managed Persistent Volume and Claim
    ## Requires persistence.enabled: true
    ## If defined, PVC must be created manually before volume will be bound
    existingClaim: postgres-pv-claim

    ## database data Persistent Volume Storage Class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is
    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
    ##   GKE, AWS & OpenStack)
    ##
    # storageClass: "-"
    accessMode: ReadWriteOnce
    size: 8Gi
    subPath: "postgresql-db"
    mountPath: /var/lib/postgresql/data/pgdata
  ## Configure resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    requests:
      memory: 256Mi
      cpu: 100m

  service:
    type: ClusterIP
    port: 5432
    externalIPs: []
    ## Manually set NodePort value
    ## Requires service.type: NodePort
    # nodePort:

  networkPolicy:
    ## Enable creation of NetworkPolicy resources.
    ##
    enabled: false
    ## The Policy model to apply. When set to false, only pods with the correct
    ## client label will have network access to the port PostgreSQL is listening
    ## on. When true, PostgreSQL will accept connections from any source
    ## (with the correct destination port).
    ##
    allowExternal: true

  ## Node labels and tolerations for pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  nodeSelector: {}
  tolerations: []
  affinity: {}

  # Override default liveness & readiness probes
  probes:
    liveness:
      initialDelay: 60
      timeoutSeconds: 5
      failureThreshold: 6
    readiness:
      initialDelay: 5
      timeoutSeconds: 3
      periodSeconds: 5
  ## Annotations for the deployment and nodes.
  deploymentAnnotations: {}
  podAnnotations: {}

  ## Deployment pods replace strategy
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
  # strategy: {}
